目錄
Part I 修改機制
Chapter 1 修改軟體
1.1 修改軟體的四個起因
1.2 危險的修改

Chapter 2 帶著回饋工作
2.1 什麼是單元測試
2.2 高層測試
2.3 測試覆蓋
2.4 遺留程式碼修改演算法

Chapter 3 感測和分離
3.1 偽裝成合作者

Chapter 4 接縫模型
4.1 一大段文字
4.2 接縫
4.3 接縫類型

Chapter 5 工具
5.1 自動化重構工具
5.2 仿物件
5.3 單元測試控制工具
5.4 一般測試控制工具

Part II 修改程式碼的技術
Chapter 6 時間緊迫，但必須修改
6.1 新生方法
6.2 新生類別
6.3 外覆方法
6.4 外覆類別
6.5 小結

Chapter 7 漫長的修改
7.1 理解程式碼
7.2 時滯
7.3 解依賴
7.4 小結

Chapter 8 添加特性
8.1 測試驅動開發
8.2 差異式程式設計
8.3 小結

Chapter 9 無法將類別放入測試控制工具之中
9.1 令人惱火的參數
9.2 隱藏依賴
9.3 構造塊
9.4 惱人的全域依賴
9.5 可怕的包含依賴
9.6 「洋蔥」參數
9.7 化名參數

Chapter 10 無法在測試控制工具中執行方法
10.1 隱藏的方法
10.2 「有益的」語言特性
10.3 無法探知的副作用

Chapter 11 修改時應當測試哪些方法
11.1 推測程式碼修改所產生的影響
11.2 前向推測
11.3 影響的傳播
11.4 進行影響推測的工具
11.5 從影響分析當中學習
11.6 簡化影響結構示意圖

Chapter 12 在同一個地方進行多處修改，是否應該將所有相關的類別都解依賴
12.1 攔截點
12.2 透過匯點來判斷設計的好壞
12.3 匯點的陷阱

Chapter 13 修改時應該怎樣寫測試
13.1 特徵測試
13.2 刻畫類別
13.3 目標測試
13.4 編寫特徵測試的啟發式方法

Chapter 14 棘手的函式庫依賴問題

Chapter 15 到處都是API 呼叫

Chapter 16 對程式碼的理解不足
16.1 註記/草圖
16.2 清單標註
16.3 草稿式重構
16.4 刪除不用的程式碼

Chapter 17 程式毫無結構可言
17.1 講解系統的故事
17.2 Naked CRC
17.3 反省你們的交流或討論

Chapter 18 測試程式碼礙手礙腳
18.1 類別命名約定
18.2 測試程式碼放在哪裡

Chapter 19 對非物件導向的專案，如何安全地對它進行修改
19.1 一個簡單的案例
19.2 一個棘手的案例
19.3 添加新行為
19.4 利用物件導向的優勢
19.5 一切都是物件導向

Chapter 20 處理大類別
20.1 職責識別
20.2 其他技術
20.3 繼續前進
20.4 類別提取之後

Chapter 21 需要修改大量相同的程式碼
21.1 開始步驟

Chapter 22 要修改一個巨型方法，卻沒辦法為它編寫測試
22.1 巨型方法的種類
22.2 利用自動重構支援來對付巨型方法
22.3 手動重構的挑戰
22.4 策略

Chapter 23 降低修改的風險
23.1 超感編輯（Hyperaware Editing）
23.2 單一目標的編輯
23.3 簽章保持
23.4 依靠編譯器

Chapter 24 當你感到絕望時

Part III 解依賴技術
Chapter 25 解依賴技術
25.1 參數適配
25.2 分解出方法物件
25.3 定義補全
25.4 封裝全域參照
25.5 暴露靜態方法
25.6 提取並覆寫呼叫
25.7 提取並覆寫工廠方法
25.8 提取並覆寫獲取方法
25.9 實作提取
25.10 介面提取
25.11 引入實例委託
25.12 引入靜態設置方法
25.13 連接替換
25.14 參數化建構子
25.15 參數化方法
25.16 樸素化參數
25.17 特性提升
25.18 依賴下推
25.19 換函數為函數指標
25.20 以獲取方法替換全域參照
25.21 子類別化並覆寫方法
25.22 替換實例變數
25.23 模板重定義
25.24 文字重定義

Appendix 重構
方法提取

術語表
